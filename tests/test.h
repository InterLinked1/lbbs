/*
 * LBBS -- The Lightweight Bulletin Board System
 *
 * Copyright (C) 2023, Naveen Albert
 *
 * Naveen Albert <bbs@phreaknet.org>
 */

/*! \file
 *
 * \brief Test Framework Modules
 *
 * \author Naveen Albert <bbs@phreaknet.org>
 */

#define BBS_TEST_FRAMEWORK

#if defined(TEST_IN_CORE) || (!defined(TEST_MODULE_SELF_SYM) && (defined(STANDALONE) || defined(STANDALONE2) || defined(TEST_NOT_MODULE)))
#define TEST_MODULE_SELF NULL
#elif defined(TEST_MODULE_SELF_SYM)
/*! Retrieve the 'struct test_module *' for the current module. */
#define TEST_MODULE_SELF TEST_MODULE_SELF_SYM()
struct test_module;
/* Internal/forward declaration, TEST_MODULE_SELF should be used instead. */
struct test_module *TEST_MODULE_SELF_SYM(void);
#else
#error "Externally compiled modules must declare TEST_MODULE_SELF_SYM."
#endif

/* Don't be fooled.
 * This program is not linked to the main BBS binary,
 * so arbitrarily including headers for the BBS
 * generally won't be useful.
 * However, bbs.h contains lots of convenience macros
 * that we can certainly use here as well.
 * (It does include some functions we may NOT use since there is no linkage to them.)
 */
#include "include/bbs.h"

/* Allow the use of dprintf and other friends we generally avoid in the main BBS */
#undef dprintf
#undef pthread_create
#undef pthread_join
#undef strcat

/* Don't allow bbs_verb, the test framework has no verbose level */
#undef bbs_verb

#define LBBS_BINARY "/usr/sbin/lbbs"
#define TEST_ROOT_DIR "/tmp/test_lbbs"
#define TEST_CONFIG_DIR DIRCAT(TEST_ROOT_DIR, "etc")
#define TEST_MAIL_DIR DIRCAT(TEST_ROOT_DIR, "maildir")
#define TEST_NEWS_DIR DIRCAT(TEST_ROOT_DIR, "newsdir")
#define TEST_TRANSFER_DIR DIRCAT(TEST_ROOT_DIR, "ftp")
#define TEST_GOPHER_DIR DIRCAT(TEST_ROOT_DIR, "gopherdir")
#define TEST_HOME_DIR_ROOT DIRCAT(TEST_TRANSFER_DIR, "home")
#define TEST_WWW_DIR DIRCAT(TEST_ROOT_DIR, "www")

/* Separate top-level directory used, to make it easier to give the mysql user permissions for it */
#define TEST_MYSQL_DIR TEST_ROOT_DIR "_mysql"

/*! \brief Create directory if it doesn't already exist */
#define TEST_MKDIR(dir) if (mkdir(dir, 0700) && errno != EEXIST) { bbs_error("mkdir(%s) failed: %s\n", dir, strerror(errno)); return -1; }

/*! \brief Delete any existing directory and recreate it */
#define TEST_RESET_MKDIR(dir) system("rm -rf " dir); TEST_MKDIR(dir);

#define TEST_CONFIGS_SRC_DIR "configs"

#define TEST_EXEC(cmd) if (system(cmd)) { bbs_error("system(%s) failed: %s\n", cmd, strerror(errno)); goto cleanup; }

/* Yuck, but why reinvent the wheel */
#define TEST_COPY_CONFIG(src, dst) if (system("cp " src " " dst)) { bbs_error("system(cp %s %s) failed: %s\n", src, dst, strerror(errno)); return -1; }
#define TEST_ADD_CONFIG_NAME(srcfilename, dstfilename) TEST_COPY_CONFIG(TEST_CONFIGS_SRC_DIR "/" srcfilename, TEST_CONFIG_DIR "/" dstfilename)
#define TEST_ADD_CONFIG_INTO_DIR(filename, dir) TEST_COPY_CONFIG(TEST_CONFIGS_SRC_DIR "/" filename, dir)
#define TEST_ADD_CONFIG(filename) TEST_ADD_CONFIG_NAME(filename, filename)
#define TEST_ADD_SUBCONFIG(subdir, filename) TEST_ADD_CONFIG_NAME(subdir "/" filename, filename)

#define TEST_HOSTNAME "bbs.example.com"

#define TEST_EMAIL_UNAUTHORIZED "unauthorized" "@" TEST_HOSTNAME
#define TEST_EXTERNAL_DOMAIN "example.net"
#define TEST_EMAIL_EXTERNAL "external@" TEST_EXTERNAL_DOMAIN
#define TEST_EMAIL_NONEXISTENT "nonexistent@" TEST_HOSTNAME

/*! \note SASL encodings generated by external/saslencode */

#define TEST_USER "testuser"
#define TEST_PASS "P@ssw0rd"
#define TEST_PASS_BASE64 "UEBzc3cwcmQ="
#define TEST_HASH "$2y$10$1vtttulZgw5Sz.Ks8PePFumnPCztHfp0YzgHLnuIQ1vAb0mSQpv2q"
#define TEST_SASL "dGVzdHVzZXIAdGVzdHVzZXIAUEBzc3cwcmQ="
#define TEST_EMAIL TEST_USER "@" TEST_HOSTNAME

#define TEST_EMAIL_ALIAS "aliasuser@" TEST_HOSTNAME

#define TEST_USER2 "testuser2"
#define TEST_PASS2 "P@ssw0rD"
#define TEST_HASH2 "$2y$10$0hcFFDyIUBkNcqMPw9G0t.vR.c8oBArJJOE1tK1atcPWkk9XBhvzK"
#define TEST_SASL2 "dGVzdHVzZXIyAHRlc3R1c2VyMgBQQHNzdzByRA=="
#define TEST_EMAIL2 TEST_USER2 "@" TEST_HOSTNAME

#define TEST_USER3 "testuser3"
#define TEST_PASS3 "P@ssw0rD"
#define TEST_HASH3 "$2y$10$0hcFFDyIUBkNcqMPw9G0t.vR.c8oBArJJOE1tK1atcPWkk9XBhvzK"
#define TEST_SASL3 "dGVzdHVzZXIyAHRlc3R1c2VyMgBQQHNzdzByRA=="

#define TEST_USER4 "termtest"
#define TEST_PASS4 "TERMPASS"
#define TEST_HASH4 "$2y$10$aa80TI0jN6Dqq3G5ctBKruBFwL6iYCCPNJ6vV7TjZ.xN1enqPrODq"

#define ENDL "\r\n"

int test_dir_file_count(const char *directory);

#define TEST_BBS_EXPECT(s, ms) if (test_bbs_expect(s, ms)) { goto cleanup; }

int test_bbs_expect(const char *s, int ms);

int test_preload_module(const char *module);
int test_load_module(const char *module);
void test_autoload_all(void);
void test_use_mysql(void);

int test_make_socket(int port);

int test_client_expect(int fd, int ms, const char *s, int line);
int test_client_expect_buf(int fd, int ms, const char *s, int line, char *buf, size_t len);
int test_client_expect_eventually(int fd, int ms, const char *s, int line);
int test_client_expect_eventually_buf(int fd, int ms, const char *s, int line, char *buf, size_t len);
int test_client_drain(int fd, int ms);

#define CLIENT_EXPECT(fd, s) if (test_client_expect(fd, SEC_MS(5), s, __LINE__)) { goto cleanup; }
#define CLIENT_EXPECT_BUF(fd, s, buf) if (test_client_expect_buf(fd, SEC_MS(5), s, __LINE__, buf, sizeof(buf))) { goto cleanup; }
#define CLIENT_EXPECT_EVENTUALLY(fd, s) if (test_client_expect_eventually(fd, SEC_MS(5), s, __LINE__)) { goto cleanup; }
/* We really may need up to 150ms when under valgrind */
#define CLIENT_DRAIN(fd) test_client_drain(fd, 150)

#define REQUIRE_FD(fd) if (fd < 0) { bbs_error("File descriptor is not set\n"); return -1; }

#define DIRECTORY_EXPECT_FILE_COUNT(dir, cnt) { \
	int _dir_cnt = test_dir_file_count(dir); \
	if (_dir_cnt != cnt) { \
		bbs_error("Expected to find %d file%s in directory %s but actually found %d?\n", cnt, ESS(cnt), dir, _dir_cnt); \
		goto cleanup; \
	} \
}

#define DIRECTORY_EXPECT_EXISTS(dir) { \
	int _dir_cnt = test_dir_file_count(dir); \
	if (_dir_cnt < 0) { \
		bbs_error("Directory %s does not exist\n", dir); \
		goto cleanup; \
	} \
}

struct test_module_info {
	struct test_module *self;
	int (*pre)(void);
	int (*run)(void);
	int (*post)(void);
	const char *name;
	const char *description;
	unsigned int flags;
};

void test_module_register(const struct test_module_info *modinfo);

void test_module_unregister(const struct test_module_info *modinfo);

#if !defined(TEST_IN_CORE)
static const __attribute__((unused)) struct test_module_info *test_module_info;
#endif

#define TEST_MODULE_INFO(flags_to_set, desc, fields...)	\
	static struct test_module_info 				\
		__mod_info = {					\
		.name = TEST_MODULE,				\
		.flags = flags_to_set,				\
		.description = desc,				\
		fields						\
	};						\
	static void  __attribute__((constructor)) __reg_module(void) \
	{ \
		test_module_register(&__mod_info); \
	} \
	static void  __attribute__((destructor)) __unreg_module(void) \
	{ \
		test_module_unregister(&__mod_info); \
	}                                                             \
	struct test_module *TEST_MODULE_SELF_SYM(void)                       \
	{                                                                  \
		return __mod_info.self;                                        \
	}                                                                  \
	static const struct test_module_info *test_module_info = &__mod_info

/* In theory, the 2 dependency cases are not mutually exclusive.
 * For example, a module could have a dependency on another module,
 * and itself also have dependents (other modules depend on it).
 * But so far, that case hasn't happened, so this simplifies things for now. */

/* For most modules */
#define TEST_MODULE_INFO_STANDARD(desc)	 \
	TEST_MODULE_INFO(0, desc,   			\
		.pre = pre,			\
		.run = run,			\
	)

/* When additional cleanup is required after BBS has exited */
#define TEST_MODULE_INFO_POST(desc)	 \
	TEST_MODULE_INFO(0, desc,   			\
		.pre = pre,			\
		.run = run,			\
		.post = post,	\
	)
